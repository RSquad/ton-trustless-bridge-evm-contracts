
# Документация к подсистеме “EVM смарт-контракты” системы “TON Trustless Bridge”

# О документе

Данный документ представляет собой краткую документацию к подсистеме “EVM смарт-контракты” (далее — EVMSmc) системы “TON Trustless Bridge” (далее — Система).

Документ предназначен для внутреннего ознакомления и призван сформировать единое представление о работе EVMSmc у всех участников процесса разработки Системы.

Документ содержит:
 - описание функциональных возможностей EVMSmc;
 - описание состава EVMSmc;
 - описание основных сценариев взаимодействия с EVMSmc и их ресурсную оценку;
 - ссылки на исходный код EVMSmc и иные материалы.

Документ не содержит:
 - описание служебных подсистем для сбора данных;
 - описание работы других подсистем Системы;
 - описание работы Системы вцелом.

# Глоссарий

 - Система — cистема “TON Trustless Bridge”;
 - EVMSmc — подсистема “EVM смарт-контракты”;
 - Валидаторы — список валидаторов некоторой эпохи блокчейна TON;

# Функциональные возможности EVMSmc
EVMSmc предоставляет следующие функциональные возможности:
 - получение, хранение и изменение валидаторов;
 - получение, хранение и валидация блоков мастерчейна;
 - получение и валидация шард-блоков;
 - парсинг сообщений шард-блоков;
 - исполнение действий согласно данных сообщений шард-блоков.

# Основные сценарии работы EVMSmc

Далее описаны сценарии взаимодействия с смарт-контрактами EVMSmc. Каждый сценарий содержит описание, алгоритм воспроизведения и оценку (в газе) вызовов методов, необходимых для выполнения сценария.
Оценка стоймости методов в газе написана для **одиночного** вызова метода (в системе есть сценарии, требующие неоднократных вызовов определенных методов, что следует учитывать при итоговой оценки стоймости выполнения того или иного сценария).

## 1. Инициализация EVMSmc
### 1.1 Деплой EVMSmc

#### **Описание**
Данный сценарий демонстрирует алгоритм деполя EVMSmc.

#### **Алгоритм воспроизведения**
1. Вызвать скрипт деплоя для смарт-контракта TreeOfCellsParser
2. Вызвать скрипт деплоя для смарт-контракта BlockParser
3. Вызвать скрипт деплоя для смарт-контракта SignatureValidator, передаем в него адрес смарт-контракта BlockParser
4. Вызвать скрипт деплоя для смарт-контракта ShardValidator
5. Вызвать скрипт деплоя для смарт-контракта Validator, передаем в него адрес смарт-контракта SignatureValidator, адрес смарт-контракта ShardValidator, адрес смарт-контракта TreeOfCellsParser
6. Вызвать скрипт деплоя для смарт-контракта TransactionParser
7. Вызвать скрипт деплоя для смарт-контракта Bridge, передаем в него адрес смарт-контракта BlockParser, адрес смарт-контракта TransactionParser, адрес смарт-контракта TreeOfCellsParser, адрес смарт-контракта Validator
8. (*) Вызвать скрипт деплоя для смарт-контракта Adapter

(*) смарт-контракт Adapter в данном случае - смарт-контракт, наследуемый от интерфейса IBaseAdapter и содержащий реализацию публичного метода интерфейса execute. Конкретная реализация метода может отличаться, в зависимости от предназначения адаптера (пример из теста - min n-ного количества токенов на эфириумный адрес, количество токенов для печати и адрес метод получает из boc'а транзакции ton'а).

*Пример реализации можно посмотреть в тесте test/transaction-1.test.ts строка 21*

#### **Оценка стоимости сценария (затраченный газ)**

| Метод | gas price |
|---|---|
| deploy BlockParser  | 2723533  |
| deploy Bridge  | 1307566  |
| deploy shardValidator  | 2320052  |
| deploy SignatureValidator  | 5141879  |
| deploy TransactionParser  | 1949056  |
| deploy TreeOfCellsParser  | 4266822  |
| deploy Validator  | 2350816  |
| deploy Adapter  | 1743421  |

### 1.2 Инициилизация валидаторов
#### **Описание**
Данный сценарий демонстрирует первое обновление списка валидаторов в контракте, когда система только задеплоена. Сам сценарий нужен для того чтобы система могла начать валидацию не с zero block’а, а с актуальной эпохи валидаторов.
#### **Предусловия**
 - Система задеплоена
 - Список валидаторов в контракте пуст
 - Вызывающим метод setValidatorSet() контракта Validator является овнером этого контракта
 - У пользователя есть спруненный ключевой блок мастерчейна со спиком валидаторов и (опционально) boc’и поддеревьев хэшмапа списка валидаторов, если таковых много (связано с ограниченим системы в 100 ячеек для tree of cell).

#### **Алгоритм воспроизведения**
1. Вызываем метод parseCandidatesRootBlock смарт-контракта Validator, передаем в него boc блока со списком валидаторов. В результате в системе будет храниться root_hash этого блока, часть валидаторов, которая находится в этом блока как “кандидаты” в валидаторы (максимум 100), хэши спруненных ячеек хэшмапа списка валидаторов.
2. (Опционально) Вызываем метод parsePartValidators смарт-контракта Validator, передаем в него boc с поддеревом хэшмапа валидаторов. Повторяем процедуру для каждого поддерева. В результате в контракте в списке кандидатов в валидаторы будет хранится топ 100 валидаторов по весу; общий вес этих валидаторов; root_hash ключевого блока со списком валидаторов. Список хэшей спруненных ячеек хэшмапа валидаторов же будет пуст, так как мы прочли все части блока. В метод нельзя 
3. Вызываем метод setValidatorSet смарт-контракта Validator. Если мы являемся владельцем контракта, то в результате система запомнит хэш блока с валидаторами как хэш валидного блока, кандидаты в валидаторы станут валидаторами, общий вес валидаторов так же обновится. Поля root_hash, кандидаты в валидаторы, общий вес кандидатов сбросятся.

*Пример реализации можно посмотреть в тесте test/transaction-1.test.ts строка 72*

#### **Негативные сценарии**
 - Пользователь не является владельцем контракта. В таком случае он все равно может заполнить кандидатов, но setValidatorsSet не отработат, для этого придется просить владельца контракта вызвать этот метод (и владельцу желательно проверить то что хэш блока находится в блокчейне и кто находится в списке кандидатов, т.к. в состоянии системы еще нет данных для полной проверки этих данных)
 - Пользователь не передал в систему поддеревья списка валидаторов, хотя таковые имеются. Метод setValidatorsSet не отработает пока блок с валидаторами не будет прочтен полностью (а точнее пока не будут считаны все валидаторы). Если пользователь каким-то образом потерял boc’и поддеревьев и не может их восстановить или он решил что система должна начать работу с другого ключевого блока с валидаторами, он может вызвать метод parseCandidatesRootBlock с другими данными, таким образом, алгоритм начнется заново.
 - Пользователь повторно вызвал метод parseCandidatesRootBlock смарт-контракта Validator до вызова метода setValidatorSet. Алгоритм придется воспроизводить заново, потому что система удалила данные о кандидатах и текущем ключевом блоке для рассмотрения.
 - В системе уже есть список валидаторов. Пользователь сможет заполнить список кандидатов, но для корректной отработки setValidatorSet смарт-контракта Validator ему потребуется проверить подписи текущего списка валидаторов на ключевом блоке, который он подал. См. 2. Обновление списка валидаторов. 

#### **Оценка стоимости сценария (затраченный газ)**
| Метод | gas price |
|---|---|
| parseCandidatesRootBlock  | 16674671  |
| parsePartValidators  | 11023565  |
| setValidatorSet  | 2322654  |


## 2. Обновление списка валидаторов
#### **Описание**
Чтение блока со списком валидаторов происходит по той же логике, что в пунктах 1.1.1, 1.1.2. После того как контракт сохранит список потенциально новых валидаторов, нужно проверить то, подписан ли ключевой блок с новыми валидаторами. За раз можно проверить 20 подписей. Для данной операции нужно вызвать метод verifyValidators смарт-контракта Validator, передать в него пустой root_hash,  file hash блока и список из 20 объектов с данными о сигнатуре (node_id валидатора, который подписывал эту сигнатуру, r, s).

root_hash = "0x0000000000000000000000000000000000000000000000000000000000000000";
verifyValidators(root_hash, fileHash, {node_id, r, s}[20]);

(*) root_hash в данном случае нулевой, так как система уже хранит root_hash блока с валидаторами, которых мы уже сохранили как кандидаты в валидаторы.

После того, как все подписи проверены, нужно вызвать метод setValidatorSet смарт-контракта Validator. В данном случае контракт проверит что вес проголосовавших за этот блок более ⅔ от общего веса топ 100 валидаторов.
Пример реализации можно посмотреть в тесте test/transaction-1.test.ts строка 124
#### **Оценка стоимости сценария (затраченный газ)**

| Метод | gas price |
|---|---|
| verifyValidators  | 26234424  |
| setValidatorSet  | 3364531  |

## 3. Валидация блоков мастерчейна
В системе есть несколько вариантов валидации блоков мастерчейна, если блок пройдет проверку, то контракт сохранит его root_hash для дальнейшей работы.

### 3.1. Валидация блоков мастерчейна с использованием подписей валидаторов
#### **Описание**
Данный сценарий демонстрирует проверку некоторого блока с помощью подписей валидатора из той же эпохи (подразумевается, что EVMSmc в момент проверки хранит в себе список валидаторой той же эпохи).
#### **Предусловия**
 - Система хранит актуальный список валидаторов.
 - Блок мастерчейна подаваемый на валидацию был подписан актуальным списком валидаторов в сети TON.
 - Пользователь имеет хэш подаваемого на валидацию блока мастерчейна и имеет список подписей этого блока.
#### **Алгоритм воспроизведения**
1. Вызываем метод verifyValidators смарт-контракта Validator, передаем в него root_hash, file hash блока и список из 20 объектов с данными для проверки подписи. Повторяем шаг до тех пор, пока мы не проверим все имеющиеся подписи. Информация для проверки подписей проверяется с помощью Ed25519, при успешной проверке система сохранит у валидаторов, которые подписывали данный блок, его хэш, что необходимо для подсчета весе подписавших блок. 
2. Вызываем метод addCurrentBlockToVerifiedSet смарт-контракта Validator, передаем в него root_hash блока, который хотим проверить. Если вес подписавших блок составляет не менее ⅔ от общего веса сохраненных в системе валидаторов, хэш блока сохранится в системе и данный блок будет считаться валидным (другими словами, он считается находящемся в оригинальном блокчейне)
*Пример реализации можно посмотреть в тесте test/transaction-1.test.ts строка 169*
#### **Негативные сценарии**
 - Если не подать данные для проверки подписи для всех топ 100 валидаторов или же подать хотя и корректные, но неподходящие для текущего блока данные для проверки подписи, то у пользователя не получится набрать достаточное количество “подписавших” блок валидаторов в системе. То же самое касается как хэш блока, так и file_hash блока, т.к. они являются частью сигнатуры, для которой проверяются подписи валидаторов.
 - Если в массиве подписей будут невалидные данные или сигнатуры для валидаторов, которых нет в списке, метод verifyValidators вернет ошибку и транзакция не сработает.

#### **Оценка стоимости сценария (затраченный газ)**
| Метод | gas price |
|---|---|
| addCurrentBlockToVerifiedSet  | 370239  |
| verifyValidators  | 26217318  |


### 3.2 Валидация блоков мастерчейна с использованием блоков потомков
#### **Описание**
Данный сценарий можно использовать, если в системе уже хранится root_hash некоторого блока из мастерчейна. В таком случае мы можем с помощью пруфа к предыдущему блоку провалидировать этот предыдущий блок.
#### **Предусловия**
 - В системе сохранен хэш ключевого блока (как валидный блок), который идет следующим в блокчейне за тем, который мы хотим проверить.
 - Пользователь имеет boc пруфа к предыдущему блоку (то есть пруф того что проверяемый блок является предыдущим к тому, который сохранен в системе).
#### **Алгоритм воспроизведения**
1. Вызываем метод addPrevBlock смарт-контракта Validator, передаем в него boc пруфа к предыдущему блоку. Метод прочитает данные из пруфа и, если хэш блока, от которого мы взяли пруф валиден и пруф имеет соответствующую структуру, система запомнит соответствующих хэш предыдущего блока из пруфа как валидный хэш блока.
#### **Оценка стоимости сценария (затраченный газ)**
| Метод | gas price |
|---|---|
| addPrevBlock  | 3205915  |

### 3.3 Валидация блоков мастерчейна через стейт
#### **Описание**
Данный сценарий демонстрирует валидацию блоков через пруф стейта блоков.
Пруф с new_hash - спруненный блок, в котором содержится new_hash стейта мастерчейна (структура пути до этого поле соответствует описанию с tlb блока). 
#### **Предусловия**
 - Пользователь имеет boc блока с new_hash (блок должен быть провалидирован одним из методов валидации системы)
 - Пользователь имеет boc стейт пруфа с путем от state_hash до hash блока мастерчайна в котором  закрывается шард.
#### **Постусловия**
По окончания работы сценария, система смарт-контрактов сохранит хэши блоков мастерчейна, содердащиеся в переданном стейт пруфе.
#### **Алгоритм воспроизведения**
1. Вызываем метод readMasterProof смарт-контракта Validator, передаем в него boc блока с полем new_hash. Смарт-контракт сохранит в системе new_hash стейта для блока, спруненный boc которого был подан в метод
2. Вызываем метод readStateProof смарт-контракта Validator, передаем в него boc стейт-пруфа и хэш блока из п.(A). Смарт контракт проверит что хэш поданного boc’а совпадает с сохраненным ранее new_hash и сохранит хэши (block refs) из boc’а, соответствующие хэшам блоков мастерчейна
*Пример реализации можно посмотреть в тесте test/transaction-1.test.ts строка 215*
#### **Негативные сценарии**
 - Если блок, boc которого мы используем для валидации стейта еще не валидировался системой, методы не выполнятся
 - Если структура boc’ов не соответствует частичной структуре boc’а блока, то методы не выполнятся (под частичной структурой подразумевается что они могут быть спрунены, но все искомые поля, вроде стейта с полем new_hash или списка предыдущих блоков должны находиться в блоке в соответствие со структурой блока, описанной в tlb)
#### **Оценка стоимости сценария (затраченный газ)**
| Метод | gas price |
|---|---|
| readMasterProof  | 2967966  |
| readStateProof  | 8021847  |


## 4. Валидация шард-блоков
### 4.1 Валидация шард-блоков через доказательство закрытия в мастерчейн
#### **Описание**
Данный сценарий демонстрирует алгоритм валидации шард-блока с помощью пруфа закрытия шард-блоков в мастерчейне.
бок пруф закрытия шардов - спруненный boc блока мастерчейна, который содержит список shard блоков.
#### **Предусловия**
 - Пользователь имеет boc пруфа закрытия шарда к некоторому блоку из мастерчейна
 - Хэш блока из мастерчейна провалидирован EVMSmc и является валидным
#### **Алгоритм воспроизведения**
1. Вызываем метод parseShardProofPath смарт-контракта Validator, передаем в него boc пруфа. Если структура пруфа верна и хэш этого пруфа является валидным (и проверенным системой) хэшом блока из мастерчейна, метод сохранит все найденные хэши шард-блоков в системе как валидные хэши блоков.
*Пример реализации можно посмотреть в тесте test/transaction-1.test.ts строка 238*
#### **Негативные сценарии**
 - Если хэш блока мастерчейна еще не был провалидирован или же пруф закрытия не является спрунненным boc’ом блока транзакция не выполнится
#### **Оценка стоимости сценария (затраченный газ)**
| Метод | gas price |
|---|---|
| parseShardProofPath  | 3772682  |


## 5. Валидация, чтение данных и исполнение транзакции
#### **Описание**
Данный сценарий демонстрирует обработку транзакции из тоновского блокчейна и её проверку с помощью системы.
#### **Предусловия**
 - Блок с транзакцией, в которой есть валидное для совершение действия системой сообщение (событие), уже успешно провалидирован системой.
 - Пользователь имеет boc транзакции и спруненный boc блока, в котором сохранен путь до этой транзакции
 - Пользователь имеет адрес адаптера, который может обработать сообщения из транзакции
#### **Алгоритм воспроизведения**
1. Вызываем метод readTransaction смарт-контракта Bridge, передаем в метод boc транзакции, boc блока и адрес смарт-контракта адаптера. По окончанию работы, система выполнит операции адаптера, соответствующие сообщениям, записанным в транзакции (например, выполнится минт соответствующего токена на указанный адрес эфириума)
#### **Негативные сценарии**
 - Если блок еще не проверялся системой, сценарий не выполнится
 - Если хэш транзакции не содержится в спруненном блоке в списке транзакций (т.е. этого хэша нет там, где по структуре boc’а блока она должна находиться), сценарий не выполнится
 - Если в транзакции нет сообщений валидных для адаптеров, сценарий выполнится без ошибок, но изменений в системе не произойдет (исключение - адаптеры, в логике которых написаны дополнительные ограничения для получаемых сообщений)
#### **Оценка стоимости сценария (затраченный газ)**
| Метод | gas price |
|---|---|
| readTransaction  | 9689015  |

## 6. Создание и применение смарт-контракта Adapter в системе
#### **Описание**
Задача смарт-контракта Adapter - выполнить некоторую операцию в эфириуме при получении подходящего для этого адаптера сообщения из транзакции TON'а. EVMSmc поддерживает возможность создавать адаптеры, выполняющие различные операции, в зависимости от входящих сообщений.
#### **Предусловия**
- смарт-контракт Adapter наследуется от интерфейся IBaseAdapter и реализует метод execute

*Пример реализации смарт-контракта находится в contracts/Adapter.sol*


# Описание контрактов и интерфейсов ESMSmc
## 1. Bridge
Контракт содержит метод для валидации транзакции и вызова метода execute смарт-контракта реализующего логику Adapter'а.

### Методы

**1.1 readTransaction(bytes calldata txBoc, bytes calldata blockBoc, address adapterAddr)**
Метод проверяет валидность транзакции (нахождение транзакции в провалидированном системой блоке), считывает информацию о транзакции и передает данные для чтения сообщений транзакции в метод execute смарт-контракта, реализующего логику Adapter'а.

## 2. IBaseAdapter
Интерфейс для реализации Adapter'ов. Описывает основной метод адаптера, используемый системой.

### Методы

**2.2 execute(bytes calldata boc, CellData[100] memory cells, uint256 rootIdx)**
Метод принимает boc, tree of cells и rootIdx транзакции.

## 3. Validator

Контракт хранит хэши валидных блоков и вспомогательную информацию о этих блоках, а так же содержит методы для валидации блоков, используемые в основных сценариях взаимодействия с системой.

### Методы

**3.1 isVerifiedBlock(bytes32 rootHash) public view returns (bool)**
Метод возвращает true, если поданный хэш является провалидированным системой хэшом блока блокчейна TON.

**3.2 getPrunedCells() external view returns (CachedCell[10] memory)**
Метод возвращает список хэшей поддеревьев списка кандидатов в валидаторы. Является вспомогательным методом для проверки того что пользователь передал всю информацию о валидаторах, содержащуюся в ключевом блоке.

**3.3 getValidators() external view returns (ValidatorDescription[100] memory)**
Метод возвращает актуальный список валидаторов, сохраненный системой.

**3.4 getCandidatesForValidators() external view returns (ValidatorDescription[100] memory)**
Метод возвращает список "кандидатов" в валидаторы. "Кандидатами" являются валидаторы ключевого блока, для которых еще не окончена работа сценариев "1.2 Инициилизация валидаторов" и "2. Обновление списка валидаторов".

**3.5 parseCandidatesRootBlock(bytes calldata boc) public**
Метод принимает boc спруненного ключевого блока со списком валидаторов и сохраняет их в системе как "кандидаты" в валидаторы. Если в самом списке внутри блока содержатся спруненные ячейки, то хэши этих ячеек метод сохраняет в списке prunnedCells, подразумевая, что это поддеревья списка валидаторов, которые будут поданые в систему в дальнейшем в соответствии с пунктов 2 алгоритма воспроизведения сценария "1.2 Инициилизация валидаторов".

**3.6 parsePartValidators(bytes calldata boc) public**
Метод принимает boc поддерева списка валидаторов ключевого блока. Для корректной работы в систему уже должен быть подан спруненный ключевой блок с помощью метода 3.5 parseCandidatesRootBlock, а так же это поддерево должно соответствовать поданному блоку. Если эти условия не выполняются, метод выдаст ошибку.

**3.7 setValidatorSet() public**
Метод обновляет список текущих валидаторов в системе, сохраняя "кандидатов в валидаторы" как актуальных валидаторов.
Метод выполнит работу только при соответствии условий сценариев "1.2 Инициилизация валидаторов" и "2. Обновление списка валидаторов":
a) Список валидаторов пуст и метод был вызван владельцем контракта
б) Список валидаторов не пуст и выполнено требование по количеству подписей на ключевом блоке с новым списокм валидаторов (вес подписавших из топ 100 валидаторов составляет не менее 2/3 от общего веса топ 100 валидаторов)
Так же список кандидатов в валидаторы должен быть не пуст.

**3.8 verifyValidators(bytes32 root_h, bytes32 file_hash, Vdata[20] calldata vdata) public**
Метод принимает и проверяет данные для проверки подписей валидаторов.
root_h - (опционально) хэш проверяемого блока. Если подан нулевой хэш, проверяется хэш блока кандидатов в валидаторы. Если оба хэша нулевые метод вернет ошибку.
file_hash - file_hash блока
Vdata - массив сущностей, содержащих поля r, s подписи и node_id валидатора.

**3.9 parseShardProofPath(bytes calldata boc) public**
Метод принимает спруненный boc блока, в котором содержится закрытия шарды и сохраняет хэши шард-блоков в системе (т.е. реализует пруф шард-блоков через закрытия шард в мастерчейне). Метод выполнится, если хэш переданного boc'а блока провалидироан системой и структура части boc'а с хэшами шард-блоков соответствует описанию блока в tlb.

**3.10 addPrevBlock(bytes calldata boc) public**
Метод принимает boc пруфа блока к предыдущему блоку. Если хэш блока является провалидированным системой и структура пруфа верна, метод сохранит хэш предыдущего блока как провалидированный системой хэш.

**3.11 readMasterProof(bytes calldata boc) public**
Метод принимает спруненный boc блока, в котором содержится new_hash стейта мастерчейна и сохраняет new_hash для соответствующего хэша блока, если последний провалидирован системой.

**3.12 readStateProof(bytes calldata boc, bytes32 rh) public**
Метод принимат boc пруфа стейта и root_hash блока мастерчейна и сохраняет найденные хэши блоков из пруфа, если хэш блока мастерчейна провалидирован системой, new_hash этого блока соответствует хэшу пруфа и пруф хранит рефы блоков в соответствии с tlb.

**3.13 addCurrentBlockToVerifiedSet(bytes32 root_h) public**
Метод принимает root_hash блока и проверяет вес валидаторов, подписавших этот блок. Если вес подписавших валидаторов из топ 100 составляет не менее 2/3 веса общего списка валидаторов из топ-100, метод сохраняет хэш блока как провалидированный хэш.


## 4. ShardValidator
Вспомогательный смарт-контракт для смарт-контракта Validator. Содержит методы для валидации блоков мастерчейна и шард-блоков, исключая проверку с помощью подписей.
## 5. SignatureValidator
Вспомогательный смарт-контракт для смарт-контракта Validator. Содержит актуальный для системы список валидаторов, общий вес сохраненных валидаторов список кандидатов в валидаторы и связанные с кандидатами поля (вес кандидатов, хэш ключевого блока из которого взяты кандидаты в валидаторы и список хэшей поддеревьев конфига с валидаторами, которые еще не были прочтены). Так же содержит вспомогательные методы проверки блоков (с помощью подписей) и списков валидаторов.

**5.1 verifyValidators(root_hash, file_hash, vdata\[20\])**

Проверяет подписи валидаторов для конкретной сигнатуры (сoncat(signature_prefix, root_hash, file_hash)). Для каждого валидатора, если подпись верна, обновляется поле verified, в которое записывается root_hash, для которого была проверка.
Используется алгоритм из контракта(библиотеки) Ed25519.

**Ограничения:**

- vdata строго ограничен 20'ю элементами и в текущей реализации все элементы должны быть валидными, т.е. если пользователю необходимо проверить < 20 подписей, ему нужно дополнить массив дубликатами.

**5.2 setValidatorSet()**
Вспомогательный метод для метода 3.7 setValidatorSet смарт-контракта Validator. Реализует проверки кандидатов в валидаторы и обновляет список валидаторов.

## 6. BitReader

Контракт содержит вспомогательные методы для чтения информации из boc'а.
Большинство методов контракта увеличивают поле cursor структуры СellData (побочный эффект метода).

### Методы

**6.1 readBit(bytes calldata data, CellData[100] memory cells, uint256 cellIdx) public pure returns (uint8 value)**

Возвращает считанный бит в виде uint8.

**6.2 readBool(bytes calldata data, CellData[100] memory cells, uint256 cellIdx)**

Возвращает считанный бит в виде bool значения.

**6.3 readUint, readUint64, readUint32, readUint8 (bytes calldata data, CellData[100] memory cells, uint256 cellIdx, uint size)**

Возвращает size считанных битов в uint8, uint16, uint32, uint64, uint соответственно.

**6.4 readBytes32BitSize(bytes calldata data, CellData[100] memory cells, uint256 cellIdx, uint size)**

Возвращает size считанных битов в виде bytes32.

**6.5 readBytes32ByteSize(bytes calldata data, CellData[100] memory cells, uint256 cellIdx, uint sizeb)**

возвращает sizeb считанных байтов в виде bytes32.

**6.6 readCell(CellData[100] memory cells, uint256 cellIdx)**

Возвращает первый необработанный парсингом ref cell’а (в виде индекса).

**6.7 readUnaryLength(bytes calldata data, CellData[100] memory cells, uint256 cellIdx)**

Возвращает количество последовательно идущих единиц.

**6.8 log2Ceil(uint x)**

Логарифм с округлением вверх.

**6.8 parseDict(bytes calldata data, CellData[100] memory cells, uint256 cellIdx, uint keySize) и doParse(bytes calldata data, uint256 prefix, CellData[100] memory cells, uint256 cellIdx, uint256 n, uint256[32] memory cellIdxs)**

Возвращают релизацию Hashmap, в данном случае — массив индексов cell’ов (cellIdx). Ограничения
Метод обрабатывает до 32 элементов включительно.

## 7. BlockParser

Контракт для чтения данных блока, содержит в себе методы для проверки нахождения транзакции в блоке, а так же методы парсинга и обновления списка валидаторов.

### Методы

**7.1 computeNodeId(publicKey)**

Возвращает node_id валидатора

**7.2 readValidatorDescription(data, cellIdx, cell)**

Возвращает информацию о валидаторе

**7.3 parseDict2(data, cells, cellIdx, keySize) и  doParse2(data, prefix, cells, cellIdx, n, cellIdxs)**

Сохраняют хэши и оставшиаеся длины префиксов для pruned ячеек. Так как полный boc с валидаторами мы не можем прочесть за 1 раз, данные методы используются чтобы запомнить, какие части хэшмапа с валидаторами нам надо будет прочитать в дальнейшем.

**7.4 parseCandidatesRootBlock(boc, rootIdx, treeOfCells)**

Метод для чтения boc'а keyblock'а с спруненным списком валидаторов.
parseBlockExtra2, parseMcBlockExtra2, parseConfigParams2, parseConfigParam342 так же используются для чтения этого блока, чтобы добраться до configParams34 и, с помощью parseDict2 запомнить список спруненных ячеек, ToC'и которых нам подадут в дальнейшем.

**7.5 parsePartValidators(data, cellIdx, cells)**

Метод для чтения поддерева configParam34, сохраняет найденных валидаторов.
Если подать поддерево НЕ из текущего keyblock'а, выдаст ошибку.

**7.6 parse_block(proofBoc, proofBocInfo, proofTreeOfCells, txRootHash, transaction) и parse_block_extra(proofBoc, cells, cellIdx, txRootHash, transaction)**

Методы проверки нахождения хэша транзакции в блоке. Проверяет как наличие хэша среди хэшей cell'ов спруненного блока, так и его местоположение в дереве.

readUintLeq, check_block_info

**7.7 check_block_info(proofBoc, cells, cellIdx, transaction) и readUintLeq(proofBoc, cells, cellIdx, n)**

Методы для корректного чтения start_lt и end_lt блока, а так же проверки того, что lt транзакции находится в промежутке времени работы блока (transaction.lt >= start_lt || transaction.lt <= end_lt).


## 8. TransactionParser
Контракт для чтения данных транзакции и поиска нужного нам сообщения.

### Методы

**8.1 parseTransactionHeader(data, cells, rootIdx)**

Возвращает структуру с основной информацией о транзакции.

**8.2 parseCurrencyCollection(data, cells, cellIdx)**

Возвращает информацию о том, сколько и каких монет было использовано в транзакции в виде bytes32. 

**Ограничения:**

- Не возвращает custom currencies, только тоны.

**8.3 readCoins(data, cells, cellIdx)**

Возвращает количество тонов для какого либо поля.
  
**8.4 parseMessagesHeader(data, cells, messagesIdx)**

Возвращает messageHeader , содержащий в себе входящие и исходящие сообщения.

**8.5 parseMessage(data, cells, messageIdx)**

Возвращает результат парсинга Message.

**8.6 getDataFromMessages(bocData, cells, outMessages)**

Возвращает eht_address и amount из нужного нам сообщения.

**8.7 parseCommonMsgInfo(data, cells, messagesIdx)**

Возвращает тип сообщения (internal, outgoing external, Incoming external) и общую информацию о сообщении.

**8.8 readAddress(data, cells, messagesIdx)**

Считывает и возвращает адрес из тон-блокчейна.

**Ограничения:**

- Не реализована обработка адреса типа 3:
```
addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)
 workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
```

## 9. TreeOfCellsParser
Контракт для работы с tree of cells. Основными методами являются parseSerializedHeader - для получения информации о содержимом boc'а и get_tree_of_cells - для получения tree of cells (ToC) в ввиде массива для дальнейшего использования.

### Методы

**9.1 readInt(data, size)**

Возвращает uint256 значение, считанное из boc'а.

**9.2 parseSerializedHeader(boc)**

Возвращает информацию о содержимом boc. Метод может считать информацию с любого из трех вариантов boc.

**Ограничения:**

- Метод работает с BOC которые содержат один и только один root cell.

**9.3 get_tree_of_cells(boc, info)**

Возвращает tree of cells, соответствующее поданному boc.

**Ограничения:**

- Не может обработать boc в котором уже указаны индексы cell.
- Так как за основу взята c++ реализация, так же как и оригинал, не может работать с absent cells. Максимум cells для обрабатываемого boc — 100.

**9.4 get_indexes(boc, info)**

Возвращает массив индексов cells. При наличии индексов в boc возвращает ошибку.

**9.5 init_cell_serialization_info(data, ref_byte_size)**

Возвращает информацию о cell.

**Ограничения:**
- Не работает с absent cells

**9.6 count_setbits(n)**

вспомогательный метод, используется вместо c++ реализации get_hashes_count()

**9.7 deserialize_cell(idx, cell_slice, custom_indexes, ref_byte_size, cell_count)**

Возвращает cell.

**9.8 get_cell_slice(idx, cells_slice, custom_indexes)**

Возвращает байты cell для дальнейшей обработки.

**9.9 create_data_cell(cell_slice, refs, cell_info)**

Вспомогательный метод для 9.7 deserialize_cell, добавляет в cell refs, флаг special и сбрасывает поле cursor.

**9.10 calcHashesForToc(boc, info, cells)**

Рассчитывает хэши для всех cell'ов данного ToC.

**9.11 getHashesCount(mask), getHashesCountFromMask(mask)**

Возвращает количество хэшей на основе данного поля mask из cell'а.

**9.12 getLevel(mask) getLevelFromMask(mask)**

Возвращает максимальный level хэшей для данного поля mask из cell'а.

**9.12 isLevelSignificant(level, mask)**

Возвращает true, если данный уровень хэша важен для подсчета хэшей других cell'ов.

**9.13 getDepth(data, level, cells, cellIdx)**

Возвращает depth\[hash_i\].

**9.14 applyLevelMask(level, levelMask)**

Возвращает наложение levelMask на level. (levelMask & ((1 << level) - 1)).

**9.15 calcHashForRefs(data, cell_info, cells, i, cell_slice)**

Рассчитывает хэш текущего cell (с учетом уже посчитанных хэшей его ref'ок).

**9.16 getHash(data, level, cells, cellIdx)**

Возвращает хэш cell'а соответствующий поданному level'у.

## Примечания по контрактам

В документации не указаны методы следующих контрактов:
- Ed25519 и Sha512 - содержат соответствующий алгоритм Ed25519.

